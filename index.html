<!DOCTYPE html>
<html>
	<head>
		<style>
			.container { }
			.potentialDestination { background: #ffff00; }
			.tree1 { background: #ddd; }
		</style>
		<script src="js/jquery-1.9.0.min.js"></script>
		<script>

			// HTML5DragDrop allows for live edits to the root (live = true). 
			// It will also not alter the HTML, nor styling. You have full control.
			$.fn.html5dragdrop = function(options) {
				var defaultOptions = {
					draggables : "li",
					acceptDraggableFromElsewhere : false,
					ghosting : true,
					droppables : "ul",
					live : true, // TODO
					onDragStart : function(draggedElement, details) {

					},
					onDragCancelled : function(draggedElement, details) {

					},
					onDrop : function(draggedElement, destinationDroppable, details) {

					},
					onDrag : function(draggedElement, details) {

					}, 
					// onEnterDroppable on the next droppable is fired *before* the onLeaveDroppable of the previous droppable
					onEnterDroppable : function(draggedElement,  enteredDroppable, details) {

					},
					onHoverDroppable : function(draggedElement, hoveredDroppable, details) {

					}, 
					onLeaveDroppable : function(draggedElement, leftDroppable, details) {

					},
					/*
					// onEnterElementInDroppable on the next element is fired *before* the onLeaveElementInDroppable of the previous elm
					onEnterElementInDroppable : function(draggedElement,  enteredElement, details) {

					},
					// onEnterElementInDroppable on the next element is fired *before* the onLeaveElementInDroppable of the previous elm
					onLeaveElementInDroppable : function(draggedElement,  leftElement, details) {

					},*/
					getGhostingContent : function(draggedElement, details) {
						return draggedElement;
					}
				};
				options = $.extend(defaultOptions, options);
				var elements = this;

				elements.each(function() {
					var root = $(this);
					var draggables = root.find(options.draggables);
					var droppables = root.find(options.droppables);
					var currentlyDraggedElement = null;
					var currentlyHoveredElement = null;
					var currentlyHoveredDroppable = null;
					var elementWasDroppedSuccessfully = false;

					var randomEventNamespace = ".jQuery-html5DragDrop-" + new Date().getTime() + "-" + Math.random();
					root.data("jquery_html5dragdrop_randomeventnamespace", randomEventNamespace);

					draggables.each(function() {
						this.draggable = true;
						$(this).on("dragstart"+randomEventNamespace, function(event) {
							currentlyDraggedElement = $(event.target);
							options.onDragStart(currentlyDraggedElement, { 
								mouseLocation: getMouseLocation(event, currentlyDraggedElement, null)
							});
							// Set the ghosting image
							if (!options.ghosting) {
								event.originalEvent.dataTransfer.setDragImage($("<div/>").get(0), 0, 0);
							} else {
								var ghosting = options.getGhostingContent(currentlyDraggedElement);
								if (ghosting instanceof jQuery) {
									ghosting = ghosting.get(0);
								}
								if (ghosting instanceof Element) {
									event.originalEvent.dataTransfer.setDragImage(ghosting, 0, 0);
								}
							}
							event.stopPropagation();
						});
						$(this).on("drag"+randomEventNamespace, function(event) {
							options.onDrag(currentlyDraggedElement, { 
								mouseLocation: getMouseLocation(event, currentlyDraggedElement, null)
							});
							event.stopPropagation();
						});
						$(this).on("dragend"+randomEventNamespace, function(event) {
							// Trigger a 'leave' on the currentlyHoveredElement and currentlyHoveredDroppable
							if (currentlyHoveredDroppable && currentlyHoveredElement) {
								options.onLeaveDroppable(currentlyDraggedElement, currentlyHoveredDroppable, { 
									mouseLocation: getMouseLocation(event, currentlyDraggedElement, currentlyHoveredDroppable, currentlyHoveredElement),
									currentlyHoveredElement : currentlyHoveredElement
								});
							}	
							// Trigger a cancel or a drop, based on whether the elementWasDroppedSuccessfully
							if (elementWasDroppedSuccessfully) {
								options.onDrop(currentlyDraggedElement, currentlyHoveredDroppable, { 
									mouseLocation: getMouseLocation(event, currentlyDraggedElement, currentlyHoveredDroppable, currentlyHoveredElement),
									currentlyHoveredElement : currentlyHoveredElement
								});
							} else {
								options.onDragCancelled(currentlyDraggedElement, { 
									mouseLocation: getMouseLocation(event, currentlyDraggedElement, null)
								});
							}
							// Reset variables
							currentlyDraggedElement = null;
							currentlyHoveredDroppable = null;
							currentlyHoveredElement = null;
							elementWasDroppedSuccessfully = false;
							event.preventDefault();
							event.stopPropagation();
						});
					});

					$(document).on("dragenter"+randomEventNamespace, function(event) {
						// If we get here, the dragenter has not been stopPropagated() by any droppable, 
						// so we are now *outside* a droppable
						currentlyHoveredElement = $(event.target);
						// If currentlyHoveredDroppable is filled, this is the first dragenter event outisde the droppable
						if(currentlyHoveredDroppable !== null) {
							currentlyHoveredDroppable = null;
						}
					});

					droppables.each(function() {
						$(this).on("dragover"+randomEventNamespace, function(event) {
							// .PreventDefault() is a means of saying that we accept the draggable
							event.preventDefault();
							event.stopPropagation();
							currentlyHoveredDroppable = $(event.originalEvent.currentTarget);
							options.onHoverDroppable(currentlyDraggedElement, currentlyHoveredDroppable, { 
								mouseLocation: getMouseLocation(event, currentlyDraggedElement, currentlyHoveredDroppable, currentlyHoveredElement),
								currentlyHoveredElement : currentlyHoveredElement
							});
						});
						// dragenter on the next element is fired *before* the dragleave of the previous element
						$(this).on("dragenter"+randomEventNamespace, function(event) {
							// .PreventDefault() is a means of saying that we accept the draggable
							event.preventDefault();
							event.stopPropagation();
							currentlyHoveredElement = $(event.target);
							// Check if we really entered a new hoveredDroppable. If so, fire an event and set new hoveredDroppable
							if (!currentlyHoveredElement.closest(droppables).is(currentlyHoveredDroppable)) {
								currentlyHoveredDroppable = $(event.originalEvent.currentTarget);
								options.onEnterDroppable(currentlyDraggedElement, currentlyHoveredDroppable, { 
									mouseLocation: getMouseLocation(event, currentlyDraggedElement, currentlyHoveredDroppable, currentlyHoveredElement),
									currentlyHoveredElement : currentlyHoveredElement
								});
							}
						});
						$(this).on("dragleave"+randomEventNamespace, function(event) {
							event.preventDefault();
							event.stopPropagation();
							// Check if we really left the hoveredDroppable. If so, fire an event
							// currentlyHoveredElement cannot be set here, since event.target does NOT contain the currently Hovered Element
							if (!$(currentlyHoveredElement).closest(options.droppables).is($(this))) {
								options.onLeaveDroppable(currentlyDraggedElement, $(this), { 
									mouseLocation: getMouseLocation(event, currentlyDraggedElement, $(this), currentlyHoveredElement),
									currentlyHoveredElement : currentlyHoveredElement
								});
							}
						});
						$(this).on("drop"+randomEventNamespace, function(event) {
							event.preventDefault();
							event.stopPropagation();
							elementWasDroppedSuccessfully = true;
							currentlyHoveredDroppable = $(event.originalEvent.currentTarget);
							currentlyHoveredElement = $(event.target);
							// Actual onDrop event will be thrown at dragEnd
						});
					});

					function getMouseLocation(event, draggable, droppable, currentElement) {
						var mouseLocation = {};
						function delta(pos, within) {
							return { x: pos.x - within.left, y: pos.y - within.top };
						}
						mouseLocation.inDocument = { x: event.originalEvent.clientX, y: event.originalEvent.clientY };
						mouseLocation.inDraggable = (draggable ? delta(mouseLocation.inDocument, draggable.offset()) : null);
						mouseLocation.inDroppable = (droppable ? delta(mouseLocation.inDocument, droppable.offset()) : null);
						mouseLocation.inCurrentElement = (currentElement ? delta(mouseLocation.inDocument, currentElement.offset()) : null);
						return mouseLocation;
					}
				});

				return {
					stop : function() {
						elements.each(function() {
							var tree = $(this);
							var draggables = tree.find(options.draggables);
							var droppables = tree.find(options.droppables);
							var randomEventNamespace = tree.data("jquery_html5dragdrop_randomeventnamespace");
							// Unbind all event-listeners
							draggables.each(function() {
								this.draggable = false;
								$(this).off(randomEventNamespace);
							});
							droppables.each(function() {
								$(this).off(randomEventNamespace);
							});
						})
						
					}
				}
			};

			$(function() {

				function placeAtTarget(elementToPlace, target, details) {
					if (details.mouseLocation.inCurrentElement.y < target.height() / 3) {
						// Place before element
						target.before(elementToPlace);
					} else if (details.mouseLocation.inCurrentElement.y > target.height() * 2/3) {
						// Place after element
						target.after(elementToPlace);
					} else {
						// Place 'under'/in element
						target.append(elementToPlace);
					}
					
				}

				var treeView = $(".container").html5dragdrop({
					draggables : "li",
					droppables : "ul", //, .potentialDestination",
					live : true, // allow for live changes to the dom
					onDragStart : function(draggedElement, details) {
						draggedElement.animate({
							opacity: 0.2
						});
					},
					onDragCancelled : function(draggedElement, details) {
						$(".container").find(".potentialDestination").hide();
						draggedElement.animate({
							opacity: 1
						});
					},
					onDrop : function(draggedElement, destinationDroppable, details) {
						$(".container").find(".potentialDestination").hide();
						draggedElement.animate({
							opacity: 1
						});
						placeAtTarget(draggedElement, details.currentlyHoveredElement, details);
					},
					onDrag : function(draggedElement) {

					}, 
					onEnterDroppable : function(draggedElement,  enteredDroppable, details) {
						$(".container").find(".potentialDestination").hide();
						placeAtTarget($("<li class='potentialDestination'>&nbsp</li>"), details.currentlyHoveredElement, details);
					},
					onHoverDroppable : function(draggedElement, hoveredDroppable, details) {

					}, 
					onLeaveDroppable : function(draggedElement, leftDroppable, details) {
						
					},
					ghosting : true,
					getGhostingContent : function(draggedElement, details) {
						return draggedElement;
					}
				});
				//treeView.stop();
			});
		</script>
	</head>
	<body>
		<div class='container'>
			<ul class='tree1'>
				<li class='file1'>hai</li>
				<li class='folder'>folder
					<ul>
						<li class='file2'>file</li>
					</ul>
				</li>
			</ul>
			<ul class='tree2'>
				<li class='file21'>hai</li>
				<li class='folder21'>folder</li>
				<li class='file22'>file 2</li>
			</ul>
		</div>
		<script>
			// Analytics
		</script>
	</body>
</html>